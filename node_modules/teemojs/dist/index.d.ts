export declare type ErrorWithResponse = Error & {
    response?: import("node-fetch").Response;
};
export declare type TeemoApiProxy<TSpec extends EndpointsSpec> = {
    [TEndpoint in Exclude<keyof TSpec, "base">]: {
        [TMethod in keyof TSpec[TEndpoint]]: (region: ReqRoutes<TSpec[TEndpoint][TMethod]>, ...kwargs: ReqArgsTuple<TSpec[TEndpoint][TMethod]>) => ReqReturn<TSpec[TEndpoint][TMethod]>;
    };
} & {
    base: TeemoApi<TSpec>;
};
export declare class TeemoApi<TSpec extends EndpointsSpec> {
    /** The config for this TeemoApi. */
    readonly config: Config<TSpec>;
    /** The requesters created by this TeemoApi, keyed uniquely per api key and region. */
    private readonly _requesters;
    static createRiotApi(apiKey: string | RiotApiKeys, distFactor?: number): TeemoApi<typeof RiotApiConfig.endpoints>;
    constructor(config: Config<TSpec>);
    proxy(): TeemoApiProxy<TSpec>;
    req<TEndpoint extends keyof TSpec, TMethod extends keyof TSpec[TEndpoint]>(endpoint: TEndpoint, method: TMethod, region: ReqRoutes<TSpec[TEndpoint][TMethod]>, ...[kwargs, ..._]: ReqArgsTuple<TSpec[TEndpoint][TMethod]>): ReqReturn<TSpec[TEndpoint][TMethod]>;
    reqInternal(rateLimitId: string, methodId: string, url: string, fetchConfig: import("node-fetch").RequestInit): unknown;
    setDistFactor(factor: number): void;
}
/** Regional routing values for `tftMatchV1`, `lorRankedV1`, and `AMERICAS` for league endpoints. */
export declare enum RegionalRoute {
    /** Americas. */
    AMERICAS = 1,
    /** Asia. */
    ASIA = 2,
    /** Europe. */
    EUROPE = 3,
    /** South East Asia. Only usable with the LoR endpoints (just `lorRankedV1` for now). */
    SEA = 4,
    /** E-Sports, used in account-v1. */
    ESPORTS = 10
}
/** Platform routing values for LoL, TFT. */
export declare enum PlatformRoute {
    /** Brazil. */
    BR1 = 16,
    /** Europe, Northeast. */
    EUN1 = 17,
    /** Europe, West. */
    EUW1 = 18,
    /** Japan. */
    JP1 = 19,
    /** Korea. */
    KR = 20,
    /** Latin America, North. */
    LA1 = 21,
    /** Latin America, South. */
    LA2 = 22,
    /** North America. */
    NA1 = 23,
    /** Oceana. */
    OC1 = 24,
    /** Rusia. */
    RU = 25,
    /** Turkey. */
    TR1 = 26,
    /** Public Bet Environment. Only usable with `lolStatusV3`. */
    PBE1 = 31
}
/** Valorant platform routing values. */
export declare enum ValPlatformRoute {
    /** Asia Pacific. */
    AP = 64,
    /** Brazil. */
    BR = 65,
    /** Europe. */
    EU = 66,
    /** Latin America. */
    LATAM = 68,
    /** North America. */
    NA = 69,
    /** Korea. */
    KR = 70,
    /** Valorant E-Sports route. */
    ESPORTS = 95
}
/** Combined routing enum. */
export declare const AnyRoute: {
    [x: number]: string;
    AP: ValPlatformRoute.AP;
    BR: ValPlatformRoute.BR;
    EU: ValPlatformRoute.EU;
    LATAM: ValPlatformRoute.LATAM;
    NA: ValPlatformRoute.NA;
    KR: ValPlatformRoute.KR;
    ESPORTS: ValPlatformRoute.ESPORTS;
    /**
     * Parse a ValPlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed ValPlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    parse(str: string): ValPlatformRoute;
    BR1: PlatformRoute.BR1;
    EUN1: PlatformRoute.EUN1;
    EUW1: PlatformRoute.EUW1;
    JP1: PlatformRoute.JP1;
    LA1: PlatformRoute.LA1;
    LA2: PlatformRoute.LA2;
    NA1: PlatformRoute.NA1;
    OC1: PlatformRoute.OC1;
    RU: PlatformRoute.RU;
    TR1: PlatformRoute.TR1;
    PBE1: PlatformRoute.PBE1;
    /**
     * Converts a PlatformRoute to the corresponding RegionalRoute.
     * Useful for `tftMatchV1` endpoints which require a RegionalRoute, while
     * other TFT endpoints require a PlatformRoute.
     * @param route PlatformRoute to be converted.
     * @returns A RegionalRoute: `AMERICAS`, `ASIA`, or `EUROPE`. Will not
     * return `SEA`, which is only used by `lorRankedV1`.
     */
    toRegional(route: PlatformRoute): Exclude<RegionalRoute, RegionalRoute.SEA>;
    AMERICAS: RegionalRoute.AMERICAS;
    ASIA: RegionalRoute.ASIA;
    EUROPE: RegionalRoute.EUROPE;
    SEA: RegionalRoute.SEA;
};
/** Combined routing type. */
export declare type AnyRoute = RegionalRoute | PlatformRoute | ValPlatformRoute;
/** RegionalRoute static utility functions. */
export declare namespace RegionalRoute {
    /**
     * Parse a RegionalRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @param excludeSea (optional) if parsing SEA should result in an error.
     * @returns The parsed RegionalRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str: string, excludeSea?: false): RegionalRoute;
    function parse(str: string, excludeSea: true): Exclude<RegionalRoute, RegionalRoute.SEA>;
}
/** PlatformRoute static utility functions. */
export declare namespace PlatformRoute {
    /**
     * Converts a PlatformRoute to the corresponding RegionalRoute.
     * Useful for `tftMatchV1` endpoints which require a RegionalRoute, while
     * other TFT endpoints require a PlatformRoute.
     * @param route PlatformRoute to be converted.
     * @returns A RegionalRoute: `AMERICAS`, `ASIA`, or `EUROPE`. Will not
     * return `SEA`, which is only used by `lorRankedV1`.
     */
    function toRegional(route: PlatformRoute): Exclude<RegionalRoute, RegionalRoute.SEA>;
    /**
     * Parse a PlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two or three-letter
     * prefix to determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed PlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str: string): PlatformRoute;
}
/** ValPlatformRoute static utility functions. */
export declare namespace ValPlatformRoute {
    /**
     * Parse a ValPlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed ValPlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str: string): ValPlatformRoute;
}
/** 32-bit integer (signed). */
export declare type int = number;
/**
 * 64-bit integer (signed).
 * NOTE: Precision loss for numbers over Number.MAX_SAFE_INTEGER (~9
 * quadrilion).
 */
export declare type long = number;
/** 32-bit single-precision float. */
export declare type float = number;
/** 64-bit double-precision float. */
export declare type double = number;
/** Header information for an application or method rate limit. */
interface RateLimitType {
    readonly name: string;
    readonly headerLimit: string;
    readonly headerCount: string;
}
/** Token bucket configuration parameters. */
interface TokenBucketConfig {
    readonly distFactor?: number;
    readonly bins?: number;
    readonly binFactor?: number;
    readonly overhead?: number;
}
/**
 * Default token bucket initialization parameters before rate limits are known.
 */
interface InitialTokenBucketConfig extends TokenBucketConfig {
    readonly timespan: number;
    readonly limit: number;
}
/** Dictionary of API keys including a 'default' key. */
interface ApiKeys {
    default: string;
    [apiKeyName: string]: string | undefined;
}
/** A configuration needed to instantiate a RiotApi. */
interface Config<TSpec extends EndpointsSpec = EndpointsSpec> {
    distFactor: number;
    retries: number;
    readonly apiKeys: ApiKeys;
    readonly origin: string;
    readonly maxConcurrent: number;
    readonly defaultBuckets: readonly InitialTokenBucketConfig[];
    readonly bucketsConfig: TokenBucketConfig;
    readonly rateLimitTypeApplication: RateLimitType;
    readonly rateLimitTypeMethod: RateLimitType;
    readonly headerRetryAfter: string;
    readonly headerLimitType: string;
    readonly endpoints: TSpec;
}
/** Listing of endpoints. */
export declare type EndpointsSpec = {
    readonly [endpoint: string]: {
        readonly [method: string]: ReqSpec;
    };
};
/** Named query parameters. */
export declare type NamedParams = {
    [argName: string]: unknown;
};
/** Ordered path parameters. */
export declare type OrderedParams = {
    [argIdx: number]: unknown;
};
/**
 * ReqSpec with optional type parameters for annotating the input parameters
 * and return type.
 */
export declare type ReqSpec<_TReturn = any, _TRoutes extends AnyRoute | string = any, _TPath extends OrderedParams | NamedParams = any, _TQuery extends NamedParams = any, _TBody = any> = {
    readonly path: string;
    readonly method?: import("node-fetch").RequestInit['method'];
    readonly apiKeyName?: string;
};
/** Utility type which extracts Promise<TReturn> from a ReqSpec. */
export declare type ReqReturn<TReqSpec extends ReqSpec = ReqSpec> = TReqSpec extends ReqSpec<infer TReturn> ? Promise<TReturn> : Promise<unknown>;
/** Utility type which extracts a Region type union from a ReqSpec. */
export declare type ReqRoutes<TReqSpec extends ReqSpec = ReqSpec> = (TReqSpec extends ReqSpec<unknown, infer TRoutes> ? TRoutes : AnyRoute) | string;
/**
 * Utility type which allows top-level list fields to be replaced by single
 * non-list values of the corresponding type.
 */
export declare type AllowSingleItemLists<T> = {
    [K in keyof T]: T[K] extends Array<infer TItem> ? T[K] | TItem : T[K];
};
/**
 * Utility type which creates a { path, query, body } kwargs type from a
 * ReqSpec. Fields are made optional if they are not required.
 */
export declare type ReqArgs<TReqSpec extends ReqSpec> = TReqSpec extends ReqSpec<unknown, AnyRoute | string, infer TPath, infer TQuery, infer TBody> ? (({} extends TPath ? {
    path?: TPath | null;
} : {
    path: TPath;
}) & ({} extends TQuery ? {
    query?: AllowSingleItemLists<TQuery> | null;
} : {
    query: AllowSingleItemLists<TQuery>;
}) & (undefined extends TBody ? {
    body?: TBody;
} : {
    body: TBody;
})) : {
    path?: OrderedParams | NamedParams | null;
    query?: NamedParams | null;
    body?: unknown | null;
};
/**
 * ReqArgs but as a tuple so optional paramters can be spread.
 * HACK: see https://github.com/microsoft/TypeScript/issues/29131
 */
export declare type ReqArgsTuple<TReqSpec extends ReqSpec = ReqSpec> = {} extends ReqArgs<TReqSpec> ? [ReqArgs<TReqSpec>?] : [ReqArgs<TReqSpec>];
export declare const RiotApiConfig: {
    readonly apiKeys: {
        readonly default: null;
    };
    readonly distFactor: 1;
    readonly retries: 3;
    readonly origin: "https://{}.api.riotgames.com";
    readonly defaultBuckets: readonly [{
        readonly timespan: 1000;
        readonly limit: 1;
        readonly bins: 1;
        readonly binFactor: 1;
        readonly overhead: 0;
    }];
    readonly rateLimitTypeApplication: {
        readonly name: "application";
        readonly headerLimit: "x-app-rate-limit";
        readonly headerCount: "x-app-rate-limit-count";
    };
    readonly rateLimitTypeMethod: {
        readonly name: "method";
        readonly headerLimit: "x-method-rate-limit";
        readonly headerCount: "x-method-rate-limit-count";
    };
    readonly maxConcurrent: 500;
    readonly headerLimitType: "x-rate-limit-type";
    readonly headerRetryAfter: "retry-after";
    readonly bucketsConfig: {};
    readonly endpoints: {
        readonly accountV1: {
            /**
             * Get account by puuid
             */
            readonly getByPuuid: ReqSpec<accountV1.AccountDto, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.ESPORTS, [string] | {
                puuid: string;
            }, {}, undefined>;
            /**
             * Get account by riot id
             */
            readonly getByRiotId: ReqSpec<accountV1.AccountDto | null, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.ESPORTS, [string, string] | {
                gameName: string;
                tagLine: string;
            }, {}, undefined>;
            /**
             * Get account by access token
             */
            readonly getByAccessToken: ReqSpec<accountV1.AccountDto, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.ESPORTS, {} | [], {}, undefined>;
            /**
             * Get active shard for a player
             */
            readonly getActiveShard: ReqSpec<accountV1.ActiveShardDto | null, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.ESPORTS, {
                game: "val" | "lor";
                puuid: string;
            } | ["val" | "lor", string], {}, undefined>;
        };
        readonly championMasteryV4: {
            /**
             * Get all champion mastery entries sorted by number of champion points descending,
             */
            readonly getAllChampionMasteries: ReqSpec<championMasteryV4.ChampionMasteryDto[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
            /**
             * Get a champion mastery by player ID and champion ID.
             */
            readonly getChampionMastery: ReqSpec<championMasteryV4.ChampionMasteryDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                encryptedSummonerId: string;
                championId: long;
            } | [string, number], {}, undefined>;
            /**
             * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
             */
            readonly getChampionMasteryScore: ReqSpec<number, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly championV3: {
            /**
             * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
             */
            readonly getChampionInfo: ReqSpec<championV3.ChampionInfo, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
        };
        readonly clashV1: {
            /**
             * Get players by summoner ID.
             * ## Implementation Notes
             * This endpoint returns a list of active Clash players for a given summoner ID. If a summoner registers for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations would appear in this list.
             */
            readonly getPlayersBySummoner: ReqSpec<clashV1.PlayerDto[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerId: string;
            }, {}, undefined>;
            /**
             * Get team by ID.
             */
            readonly getTeamById: ReqSpec<clashV1.TeamDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                teamId: string;
            }, {}, undefined>;
            /**
             * Get all active or upcoming tournaments.
             */
            readonly getTournaments: ReqSpec<clashV1.TournamentDto[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get tournament by team ID.
             */
            readonly getTournamentByTeam: ReqSpec<clashV1.TournamentDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                teamId: string;
            }, {}, undefined>;
            /**
             * Get tournament by ID.
             */
            readonly getTournamentById: ReqSpec<clashV1.TournamentDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                tournamentId: int;
            } | [number], {}, undefined>;
        };
        readonly leagueExpV4: {
            /**
             * Get all the league entries.
             */
            readonly getLeagueEntries: ReqSpec<leagueExpV4.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_SOLO_5x5" | "RANKED_TFT" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
                tier: "CHALLENGER" | "GRANDMASTER" | "MASTER" | "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON";
                division: "I" | "II" | "III" | "IV";
            } | ["RANKED_SOLO_5x5" | "RANKED_TFT" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT", "CHALLENGER" | "GRANDMASTER" | "MASTER" | "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON", "I" | "II" | "III" | "IV"], {
                page?: number | null | undefined;
            }, undefined>;
        };
        readonly leagueV4: {
            /**
             * Get the challenger league for given queue.
             */
            readonly getChallengerLeague: ReqSpec<leagueV4.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
            } | ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT"], {}, undefined>;
            /**
             * Get league entries in all queues for a given summoner ID.
             */
            readonly getLeagueEntriesForSummoner: ReqSpec<leagueV4.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
            /**
             * Get all the league entries.
             */
            readonly getLeagueEntries: ReqSpec<leagueV4.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
                tier: "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON";
                division: "I" | "II" | "III" | "IV";
            } | ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT", "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON", "I" | "II" | "III" | "IV"], {
                page?: number | null | undefined;
            }, undefined>;
            /**
             * Get the grandmaster league of a specific queue.
             */
            readonly getGrandmasterLeague: ReqSpec<leagueV4.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT"] | {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
            }, {}, undefined>;
            /**
             * Get league with given ID, including inactive entries.
             */
            readonly getLeagueById: ReqSpec<leagueV4.LeagueListDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                leagueId: string;
            }, {}, undefined>;
            /**
             * Get the master league for given queue.
             */
            readonly getMasterLeague: ReqSpec<leagueV4.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT"] | {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
            }, {}, undefined>;
        };
        readonly lolStatusV3: {
            /**
             * Get League of Legends status for the given shard.
             * ## Rate Limit Notes
             * Requests to this API are not counted against the application Rate Limits.
             */
            readonly getShardData: ReqSpec<lolStatusV3.ShardStatus, PlatformRoute, {} | [], {}, undefined>;
        };
        readonly lolStatusV4: {
            /**
             * Get League of Legends status for the given platform.
             */
            readonly getPlatformData: ReqSpec<lolStatusV4.PlatformDataDto, PlatformRoute, {} | [], {}, undefined>;
        };
        readonly lorDeckV1: {
            /**
             * Get a list of the calling user's decks.
             */
            readonly getDecks: ReqSpec<lorDeckV1.DeckDto[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.SEA, {} | [], {}, undefined>;
            /**
             * Create a new deck for the calling user.
             */
            readonly createDeck: ReqSpec<string, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.SEA, {} | [], {}, lorDeckV1.NewDeckDto>;
        };
        readonly lorInventoryV1: {
            /**
             * Return a list of cards owned by the calling user.
             */
            readonly getCards: ReqSpec<lorInventoryV1.CardDto[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.SEA, {} | [], {}, undefined>;
        };
        readonly lorMatchV1: {
            /**
             * Get a list of match ids by PUUID
             */
            readonly getMatchIdsByPUUID: ReqSpec<string[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                puuid: string;
            }, {}, undefined>;
            /**
             * Get match by id
             */
            readonly getMatch: ReqSpec<lorMatchV1.MatchDto, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
        };
        readonly lorRankedV1: {
            /**
             * Get the players in Master tier.
             */
            readonly getLeaderboards: ReqSpec<lorRankedV1.LeaderboardDto, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.SEA, {} | [], {}, undefined>;
        };
        readonly lorStatusV1: {
            /**
             * Get Legends of Runeterra status for the given platform.
             */
            readonly getPlatformData: ReqSpec<lorStatusV1.PlatformDataDto, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE | RegionalRoute.SEA, {} | [], {}, undefined>;
        };
        readonly matchV5: {
            /**
             * Get a list of match ids by puuid
             */
            readonly getMatchIdsByPUUID: ReqSpec<string[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                puuid: string;
            }, {
                startTime?: number | null | undefined;
                endTime?: number | null | undefined;
                queue?: number | null | undefined;
                type?: "ranked" | "normal" | "tourney" | "tutorial" | null | undefined;
                start?: number | null | undefined;
                count?: number | null | undefined;
            }, undefined>;
            /**
             * Get a match by match id
             */
            readonly getMatch: ReqSpec<matchV5.MatchDto | null, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
            /**
             * Get a match timeline by match id
             */
            readonly getTimeline: ReqSpec<matchV5.MatchTimelineDto | null, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
        };
        readonly spectatorV4: {
            /**
             * Get current game information for the given summoner ID.
             */
            readonly getCurrentGameInfoBySummoner: ReqSpec<spectatorV4.CurrentGameInfo | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
            /**
             * Get list of featured games.
             */
            readonly getFeaturedGames: ReqSpec<spectatorV4.FeaturedGames, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
        };
        readonly summonerV4: {
            /**
             * Get a summoner by account ID.
             */
            readonly getByAccountId: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedAccountId: string;
            }, {}, undefined>;
            /**
             * Get a summoner by summoner name.
             */
            readonly getBySummonerName: ReqSpec<summonerV4.SummonerDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerName: string;
            }, {}, undefined>;
            /**
             * Get a summoner by PUUID.
             */
            readonly getByPUUID: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedPUUID: string;
            }, {}, undefined>;
            /**
             * Get a summoner by access token.
             */
            readonly getByAccessToken: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get a summoner by summoner ID.
             */
            readonly getBySummonerId: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly tftLeagueV1: {
            /**
             * Get the challenger league.
             */
            readonly getChallengerLeague: ReqSpec<tftLeagueV1.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get league entries for a given summoner ID.
             */
            readonly getLeagueEntriesForSummoner: ReqSpec<tftLeagueV1.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerId: string;
            }, {}, undefined>;
            /**
             * Get all the league entries.
             */
            readonly getLeagueEntries: ReqSpec<tftLeagueV1.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                tier: "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON";
                division: "I" | "II" | "III" | "IV";
            } | ["DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON", "I" | "II" | "III" | "IV"], {
                page?: number | null | undefined;
            }, undefined>;
            /**
             * Get the grandmaster league.
             */
            readonly getGrandmasterLeague: ReqSpec<tftLeagueV1.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get league with given ID, including inactive entries.
             */
            readonly getLeagueById: ReqSpec<tftLeagueV1.LeagueListDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                leagueId: string;
            }, {}, undefined>;
            /**
             * Get the master league.
             */
            readonly getMasterLeague: ReqSpec<tftLeagueV1.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get the top rated ladder for given queue
             */
            readonly getTopRatedLadder: ReqSpec<tftLeagueV1.TopRatedLadderEntryDto[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_TFT_TURBO";
            } | ["RANKED_TFT_TURBO"], {}, undefined>;
        };
        readonly tftMatchV1: {
            /**
             * Get a list of match ids by PUUID
             */
            readonly getMatchIdsByPUUID: ReqSpec<string[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                puuid: string;
            }, {
                count?: number | null | undefined;
            }, undefined>;
            /**
             * Get a match by match id
             */
            readonly getMatch: ReqSpec<tftMatchV1.MatchDto | null, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
        };
        readonly tftSummonerV1: {
            /**
             * Get a summoner by account ID.
             */
            readonly getByAccountId: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedAccountId: string;
            }, {}, undefined>;
            /**
             * Get a summoner by summoner name.
             */
            readonly getBySummonerName: ReqSpec<tftSummonerV1.SummonerDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerName: string;
            }, {}, undefined>;
            /**
             * Get a summoner by PUUID.
             */
            readonly getByPUUID: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedPUUID: string;
            }, {}, undefined>;
            /**
             * Get a summoner by access token.
             */
            readonly getByAccessToken: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get a summoner by summoner ID.
             */
            readonly getBySummonerId: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly thirdPartyCodeV4: {
            /**
             * Get third party code for a given summoner ID.
             */
            readonly getThirdPartyCodeBySummonerId: ReqSpec<string, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly tournamentStubV4: {
            /**
             * Create a mock tournament code for the given tournament.
             */
            readonly createTournamentCode: ReqSpec<string[], RegionalRoute.AMERICAS, {} | [], {
                count?: number | null | undefined;
                tournamentId: long;
            }, tournamentStubV4.TournamentCodeParameters>;
            /**
             * Gets a mock list of lobby events by tournament code.
             */
            readonly getLobbyEventsByCode: ReqSpec<tournamentStubV4.LobbyEventDTOWrapper, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Creates a mock tournament provider and returns its ID.
             * ## Implementation Notes
             * Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
             */
            readonly registerProviderData: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentStubV4.ProviderRegistrationParameters>;
            /**
             * Creates a mock tournament and returns its ID.
             */
            readonly registerTournament: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentStubV4.TournamentRegistrationParameters>;
        };
        readonly tournamentV4: {
            /**
             * Create a tournament code for the given tournament.
             */
            readonly createTournamentCode: ReqSpec<string[], RegionalRoute.AMERICAS, {} | [], {
                count?: number | null | undefined;
                tournamentId: long;
            }, tournamentV4.TournamentCodeParameters>;
            /**
             * Returns the tournament code DTO associated with a tournament code string.
             */
            readonly getTournamentCode: ReqSpec<tournamentV4.TournamentCodeDTO, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Update the pick type, map, spectator type, or allowed summoners for a code.
             */
            readonly updateCode: ReqSpec<void, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, tournamentV4.TournamentCodeUpdateParameters>;
            /**
             * Gets a list of lobby events by tournament code.
             */
            readonly getLobbyEventsByCode: ReqSpec<tournamentV4.LobbyEventDTOWrapper, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Creates a tournament provider and returns its ID.
             * ## Implementation Notes
             * Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
             */
            readonly registerProviderData: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentV4.ProviderRegistrationParameters>;
            /**
             * Creates a tournament and returns its ID.
             */
            readonly registerTournament: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentV4.TournamentRegistrationParameters>;
        };
        readonly valContentV1: {
            /**
             * Get content optionally filtered by locale
             */
            readonly getContent: ReqSpec<valContentV1.ContentDto, ValPlatformRoute, {} | [], {
                locale?: string | null | undefined;
            }, undefined>;
        };
        readonly valMatchV1: {
            /**
             * Get match by id
             */
            readonly getMatch: ReqSpec<valMatchV1.MatchDto | null, ValPlatformRoute, [string] | {
                matchId: string;
            }, {}, undefined>;
            /**
             * Get matchlist for games played by puuid
             */
            readonly getMatchlist: ReqSpec<valMatchV1.MatchlistDto, ValPlatformRoute, [string] | {
                puuid: string;
            }, {}, undefined>;
            /**
             * Get recent matches
             * ## Implementation Notes
             * Returns a list of match ids that have completed in the last 10 minutes for live regions and 12 hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent matches will return a combined list of matches from those three regions. Requests are load balanced so you may see some inconsistencies as matches are added/removed from the list.
             */
            readonly getRecent: ReqSpec<valMatchV1.RecentMatchesDto, ValPlatformRoute, {
                queue: "competitive" | "unrated" | "spikerush" | "tournamentmode";
            } | ["competitive" | "unrated" | "spikerush" | "tournamentmode"], {}, undefined>;
        };
        readonly valRankedV1: {
            /**
             * Get leaderboard for the competitive queue
             */
            readonly getLeaderboard: ReqSpec<valRankedV1.LeaderboardDto | null, ValPlatformRoute.AP | ValPlatformRoute.BR | ValPlatformRoute.EU | ValPlatformRoute.LATAM | ValPlatformRoute.NA | ValPlatformRoute.KR, [string] | {
                actId: string;
            }, {
                size?: number | null | undefined;
                startIndex?: number | null | undefined;
            }, undefined>;
        };
        readonly valStatusV1: {
            /**
             * Get VALORANT status for the given platform.
             */
            readonly getPlatformData: ReqSpec<valStatusV1.PlatformDataDto, ValPlatformRoute.AP | ValPlatformRoute.BR | ValPlatformRoute.EU | ValPlatformRoute.LATAM | ValPlatformRoute.NA | ValPlatformRoute.KR, {} | [], {}, undefined>;
        };
    };
};
/** API key dictionary for RiotApi endpoints. "default" corresponds to League of Legends endpoints. */
interface RiotApiKeys {
    default: string;
    tft?: string;
    lor?: string;
    tournament?: string;
    [apiKeyName: string]: string | undefined;
}
export declare namespace accountV1 {
    /**
     * AccountDto data object, automatically generated.
     */
    interface AccountDto {
        puuid: string;
        /** This field may be excluded from the response if the account doesn't have a gameName. */
        gameName?: string | null;
        /** This field may be excluded from the response if the account doesn't have a tagLine. */
        tagLine?: string | null;
    }
}
export declare namespace accountV1 {
    /**
     * ActiveShardDto data object, automatically generated.
     */
    interface ActiveShardDto {
        puuid: string;
        game: string;
        activeShard: string;
    }
}
export declare namespace championMasteryV4 {
    /**
     * ChampionMasteryDto data object, automatically generated.
     * # Description
     * This object contains single Champion Mastery information for player and champion combination.
     */
    interface ChampionMasteryDto {
        /** Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion. */
        championPointsUntilNextLevel: long;
        /** Is chest granted for this champion or not in current season. */
        chestGranted: boolean;
        /** Champion ID for this entry. */
        championId: long;
        /** Last time this champion was played by this player - in Unix milliseconds time format. */
        lastPlayTime: long;
        /** Champion level for specified player and champion combination. */
        championLevel: int;
        /** Summoner ID for this entry. (Encrypted) */
        summonerId: string;
        /** Total number of champion points for this player and champion combination - they are used to determine championLevel. */
        championPoints: int;
        /** Number of points earned since current level has been achieved. */
        championPointsSinceLastLevel: long;
        /** The token earned for this champion at the current championLevel. When the championLevel is advanced the tokensEarned resets to 0. */
        tokensEarned: int;
    }
}
export declare namespace championV3 {
    /**
     * ChampionInfo data object, automatically generated.
     */
    interface ChampionInfo {
        maxNewPlayerLevel: int;
        freeChampionIdsForNewPlayers: int[];
        freeChampionIds: int[];
    }
}
export declare namespace clashV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        summonerId: string;
        teamId?: string | null;
        /** (Legal values:  UNSELECTED,  FILL,  TOP,  JUNGLE,  MIDDLE,  BOTTOM,  UTILITY) */
        position: "UNSELECTED" | "FILL" | "TOP" | "JUNGLE" | "MIDDLE" | "BOTTOM" | "UTILITY";
        /** (Legal values:  CAPTAIN,  MEMBER) */
        role: "CAPTAIN" | "MEMBER";
    }
}
export declare namespace clashV1 {
    /**
     * TeamDto data object, automatically generated.
     */
    interface TeamDto {
        id: string;
        tournamentId: int;
        name: string;
        iconId: int;
        tier: int;
        /** Summoner ID of the team captain. */
        captain: string;
        abbreviation: string;
        /** Team members. */
        players: clashV1.PlayerDto[];
    }
}
export declare namespace clashV1 {
    /**
     * TournamentDto data object, automatically generated.
     */
    interface TournamentDto {
        id: int;
        themeId: int;
        nameKey: string;
        nameKeySecondary: string;
        /** Tournament phase. */
        schedule: clashV1.TournamentPhaseDto[];
    }
}
export declare namespace clashV1 {
    /**
     * TournamentPhaseDto data object, automatically generated.
     */
    interface TournamentPhaseDto {
        id: int;
        registrationTime: long;
        startTime: long;
        cancelled: boolean;
    }
}
export declare namespace leagueExpV4 {
    /**
     * LeagueEntryDTO data object, automatically generated.
     */
    interface LeagueEntryDTO {
        leagueId: string;
        /** Player's summonerId (Encrypted) */
        summonerId: string;
        summonerName: string;
        queueType: string;
        tier: string;
        /** The player's division within a tier. */
        rank: string;
        leaguePoints: int;
        /** Winning team on Summoners Rift. First placement in Teamfight Tactics. */
        wins: int;
        /** Losing team on Summoners Rift. Second through eighth placement in Teamfight Tactics. */
        losses: int;
        hotStreak: boolean;
        veteran: boolean;
        freshBlood: boolean;
        inactive: boolean;
        miniSeries?: leagueExpV4.MiniSeriesDTO | null;
    }
}
export declare namespace leagueExpV4 {
    /**
     * MiniSeriesDTO data object, automatically generated.
     */
    interface MiniSeriesDTO {
        losses: int;
        progress: string;
        target: int;
        wins: int;
    }
}
export declare namespace leagueV4 {
    /**
     * LeagueListDTO data object, automatically generated.
     */
    interface LeagueListDTO {
        leagueId: string;
        entries: leagueV4.LeagueItemDTO[];
        tier: string;
        name: string;
        queue: string;
    }
}
export declare namespace leagueV4 {
    /**
     * LeagueItemDTO data object, automatically generated.
     */
    interface LeagueItemDTO {
        freshBlood: boolean;
        /** Winning team on Summoners Rift. */
        wins: int;
        summonerName: string;
        miniSeries?: leagueV4.MiniSeriesDTO | null;
        inactive: boolean;
        veteran: boolean;
        hotStreak: boolean;
        rank: string;
        leaguePoints: int;
        /** Losing team on Summoners Rift. */
        losses: int;
        /** Player's encrypted summonerId. */
        summonerId: string;
    }
}
export declare namespace leagueV4 {
    /**
     * MiniSeriesDTO data object, automatically generated.
     */
    interface MiniSeriesDTO {
        losses: int;
        progress: string;
        target: int;
        wins: int;
    }
}
export declare namespace leagueV4 {
    /**
     * LeagueEntryDTO data object, automatically generated.
     */
    interface LeagueEntryDTO {
        leagueId?: string | null;
        /** Player's encrypted summonerId. */
        summonerId: string;
        summonerName: string;
        queueType: string;
        tier?: string | null;
        /** The player's division within a tier. */
        rank?: string | null;
        leaguePoints: int;
        /** Winning team on Summoners Rift. */
        wins: int;
        /** Losing team on Summoners Rift. */
        losses: int;
        hotStreak: boolean;
        veteran: boolean;
        freshBlood: boolean;
        inactive: boolean;
        miniSeries?: leagueV4.MiniSeriesDTO | null;
    }
}
export declare namespace lolStatusV3 {
    /**
     * ShardStatus data object, automatically generated.
     */
    interface ShardStatus {
        locales: string[];
        hostname: string;
        name: string;
        services: lolStatusV3.Service[];
        slug: string;
        region_tag: string;
    }
}
export declare namespace lolStatusV3 {
    /**
     * Service data object, automatically generated.
     */
    interface Service {
        name: string;
        slug: string;
        status: string;
        incidents: lolStatusV3.Incident[];
    }
}
export declare namespace lolStatusV3 {
    /**
     * Incident data object, automatically generated.
     */
    interface Incident {
        id: long;
        active: boolean;
        created_at: string;
        updates: lolStatusV3.Message[];
    }
}
export declare namespace lolStatusV3 {
    /**
     * Message data object, automatically generated.
     */
    interface Message {
        id: string;
        author: string;
        heading: string;
        content: string;
        severity: string;
        created_at: string;
        updated_at: string;
        translations: lolStatusV3.Translation[];
    }
}
export declare namespace lolStatusV3 {
    /**
     * Translation data object, automatically generated.
     */
    interface Translation {
        updated_at: string;
        locale: string;
        content: string;
    }
}
export declare namespace lolStatusV4 {
    /**
     * PlatformDataDto data object, automatically generated.
     */
    interface PlatformDataDto {
        id: string;
        name: string;
        locales: string[];
        maintenances: lolStatusV4.StatusDto[];
        incidents: lolStatusV4.StatusDto[];
    }
}
export declare namespace lolStatusV4 {
    /**
     * StatusDto data object, automatically generated.
     */
    interface StatusDto {
        id: int;
        /** (Legal values:  scheduled,  in_progress,  complete) */
        maintenance_status: "scheduled" | "in_progress" | "complete";
        /** (Legal values:  info,  warning,  critical) */
        incident_severity: "info" | "warning" | "critical";
        titles: lolStatusV4.ContentDto[];
        updates: lolStatusV4.UpdateDto[];
        created_at: string;
        archive_at: string;
        updated_at: string;
        /** (Legal values: windows, macos, android, ios, ps4, xbone, switch) */
        platforms: string[];
    }
}
export declare namespace lolStatusV4 {
    /**
     * ContentDto data object, automatically generated.
     */
    interface ContentDto {
        locale: string;
        content: string;
    }
}
export declare namespace lolStatusV4 {
    /**
     * UpdateDto data object, automatically generated.
     */
    interface UpdateDto {
        id: int;
        author: string;
        publish: boolean;
        /** (Legal values: riotclient, riotstatus, game) */
        publish_locations: string[];
        translations: lolStatusV4.ContentDto[];
        created_at: string;
        updated_at: string;
    }
}
export declare namespace lorDeckV1 {
    /**
     * DeckDto data object, automatically generated.
     */
    interface DeckDto {
        id: string;
        name: string;
        code: string;
    }
}
export declare namespace lorDeckV1 {
    /**
     * NewDeckDto data object, automatically generated.
     */
    interface NewDeckDto {
        name: string;
        code: string;
    }
}
export declare namespace lorInventoryV1 {
    /**
     * CardDto data object, automatically generated.
     */
    interface CardDto {
        code: string;
        count: string;
    }
}
export declare namespace lorMatchV1 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        /** Match metadata. */
        metadata: lorMatchV1.MetadataDto;
        /** Match info. */
        info: lorMatchV1.InfoDto;
    }
}
export declare namespace lorMatchV1 {
    /**
     * MetadataDto data object, automatically generated.
     */
    interface MetadataDto {
        /** Match data version. */
        data_version: string;
        /** Match id. */
        match_id: string;
        /** A list of participant PUUIDs. */
        participants: string[];
    }
}
export declare namespace lorMatchV1 {
    /**
     * InfoDto data object, automatically generated.
     */
    interface InfoDto {
        /** (Legal values:  Constructed,  Expeditions,  Tutorial) */
        game_mode: "Constructed" | "Expeditions" | "Tutorial";
        /** (Legal values:  Ranked,  Normal,  AI,  Tutorial,  VanillaTrial,  Singleton,  StandardGauntlet) */
        game_type: "Ranked" | "Normal" | "AI" | "Tutorial" | "VanillaTrial" | "Singleton" | "StandardGauntlet";
        game_start_time_utc: string;
        game_version: string;
        players: lorMatchV1.PlayerDto[];
        /** Total turns taken by both players. */
        total_turn_count: int;
    }
}
export declare namespace lorMatchV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        puuid: string;
        deck_id: string;
        /** Code for the deck played. Refer to LOR documentation for details on deck codes. */
        deck_code: string;
        factions: string[];
        game_outcome: string;
        /** The order in which the players took turns. */
        order_of_play: int;
    }
}
export declare namespace lorRankedV1 {
    /**
     * LeaderboardDto data object, automatically generated.
     */
    interface LeaderboardDto {
        /** A list of players in Master tier. */
        players: lorRankedV1.PlayerDto[];
    }
}
export declare namespace lorRankedV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        name: string;
        rank: int;
        /** League points. */
        lp: int;
    }
}
export declare namespace lorStatusV1 {
    /**
     * PlatformDataDto data object, automatically generated.
     */
    interface PlatformDataDto {
        id: string;
        name: string;
        locales: string[];
        maintenances: lorStatusV1.StatusDto[];
        incidents: lorStatusV1.StatusDto[];
    }
}
export declare namespace lorStatusV1 {
    /**
     * StatusDto data object, automatically generated.
     */
    interface StatusDto {
        id: int;
        /** (Legal values:  scheduled,  in_progress,  complete) */
        maintenance_status: "scheduled" | "in_progress" | "complete";
        /** (Legal values:  info,  warning,  critical) */
        incident_severity: "info" | "warning" | "critical";
        titles: lorStatusV1.ContentDto[];
        updates: lorStatusV1.UpdateDto[];
        created_at: string;
        archive_at: string;
        updated_at: string;
        /** (Legal values: windows, macos, android, ios, ps4, xbone, switch) */
        platforms: string[];
    }
}
export declare namespace lorStatusV1 {
    /**
     * ContentDto data object, automatically generated.
     */
    interface ContentDto {
        locale: string;
        content: string;
    }
}
export declare namespace lorStatusV1 {
    /**
     * UpdateDto data object, automatically generated.
     */
    interface UpdateDto {
        id: int;
        author: string;
        publish: boolean;
        /** (Legal values: riotclient, riotstatus, game) */
        publish_locations: string[];
        translations: lorStatusV1.ContentDto[];
        created_at: string;
        updated_at: string;
    }
}
export declare namespace matchV5 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        /** Match metadata. */
        metadata: matchV5.MetadataDto;
        /** Match info. */
        info: matchV5.InfoDto;
    }
}
export declare namespace matchV5 {
    /**
     * MetadataDto data object, automatically generated.
     */
    interface MetadataDto {
        /** Match data version. */
        dataVersion: string;
        /** Match id. */
        matchId: string;
        /** A list of participant PUUIDs. */
        participants: string[];
    }
}
export declare namespace matchV5 {
    /**
     * InfoDto data object, automatically generated.
     */
    interface InfoDto {
        /** Unix timestamp for when the game is created on the game server (i.e., the loading screen). */
        gameCreation: long;
        /** Prior to patch 11.20, this field returns the game length in milliseconds calculated from gameEndTimestamp - gameStartTimestamp. Post patch 11.20, this field returns the max timePlayed of any participant in the game in seconds, which makes the behavior of this field consistent with that of match-v4. The best way to handling the change in this field is to treat the value as milliseconds if the gameEndTimestamp field isn't in the response and to treat the value as seconds if gameEndTimestamp is in the response. */
        gameDuration: long;
        /** Unix timestamp for when match ends on the game server. This timestamp can occasionally be significantly longer than when the match "ends". The most reliable way of determining the timestamp for the end of the match would be to add the max time played of any participant to the gameStartTimestamp. This field was added to match-v5 in patch 11.20 on Oct 5th, 2021. */
        gameEndTimestamp?: long | null;
        gameId: long;
        /** Refer to the Game Constants documentation. */
        gameMode: string;
        gameName: string;
        /** Unix timestamp for when match starts on the game server. */
        gameStartTimestamp: long;
        gameType: string;
        /** The first two parts can be used to determine the patch a game was played on. */
        gameVersion: string;
        /** Refer to the Game Constants documentation. */
        mapId: int;
        participants: matchV5.ParticipantDto[];
        /** Platform where the match was played. */
        platformId: string;
        /** Refer to the Game Constants documentation. */
        queueId: int;
        teams: matchV5.TeamDto[];
        /** Tournament code used to generate the match. This field was added to match-v5 in patch 11.13 on June 23rd, 2021. */
        tournamentCode?: string | null;
    }
}
export declare namespace matchV5 {
    /**
     * ParticipantDto data object, automatically generated.
     */
    interface ParticipantDto {
        assists: int;
        baronKills: int;
        bountyLevel: int;
        champExperience: int;
        champLevel: int;
        /** Prior to patch 11.4, on Feb 18th, 2021, this field returned invalid championIds. We recommend determining the champion based on the championName field for matches played prior to patch 11.4. */
        championId: int;
        championName: string;
        /** This field is currently only utilized for Kayn's transformations. (Legal values: 0 - None, 1 - Slayer, 2 - Assassin) */
        championTransform: int;
        consumablesPurchased: int;
        damageDealtToBuildings: int;
        damageDealtToObjectives: int;
        damageDealtToTurrets: int;
        damageSelfMitigated: int;
        deaths: int;
        detectorWardsPlaced: int;
        doubleKills: int;
        dragonKills: int;
        firstBloodAssist: boolean;
        firstBloodKill: boolean;
        firstTowerAssist: boolean;
        firstTowerKill: boolean;
        gameEndedInEarlySurrender: boolean;
        gameEndedInSurrender: boolean;
        goldEarned: int;
        goldSpent: int;
        /** Both individualPosition and teamPosition are computed by the game server and are different versions of the most likely position played by a player. The individualPosition is the best guess for which position the player actually played in isolation of anything else. The teamPosition is the best guess for which position the player actually played if we add the constraint that each team must have one top player, one jungle, one middle, etc. Generally the recommendation is to use the teamPosition field over the individualPosition field. */
        individualPosition: string;
        inhibitorKills: int;
        inhibitorTakedowns?: int | null;
        inhibitorsLost: int;
        item0: int;
        item1: int;
        item2: int;
        item3: int;
        item4: int;
        item5: int;
        item6: int;
        itemsPurchased: int;
        killingSprees: int;
        kills: int;
        lane: string;
        largestCriticalStrike: int;
        largestKillingSpree: int;
        largestMultiKill: int;
        longestTimeSpentLiving: int;
        magicDamageDealt: int;
        magicDamageDealtToChampions: int;
        magicDamageTaken: int;
        neutralMinionsKilled: int;
        nexusKills: int;
        nexusTakedowns?: int | null;
        nexusLost: int;
        objectivesStolen: int;
        objectivesStolenAssists: int;
        participantId: int;
        pentaKills: int;
        perks: matchV5.PerksDto;
        physicalDamageDealt: int;
        physicalDamageDealtToChampions: int;
        physicalDamageTaken: int;
        profileIcon: int;
        puuid: string;
        quadraKills: int;
        riotIdName: string;
        riotIdTagline: string;
        role: string;
        sightWardsBoughtInGame: int;
        spell1Casts: int;
        spell2Casts: int;
        spell3Casts: int;
        spell4Casts: int;
        summoner1Casts: int;
        summoner1Id: int;
        summoner2Casts: int;
        summoner2Id: int;
        summonerId: string;
        summonerLevel: int;
        summonerName: string;
        teamEarlySurrendered: boolean;
        teamId: int;
        /** Both individualPosition and teamPosition are computed by the game server and are different versions of the most likely position played by a player. The individualPosition is the best guess for which position the player actually played in isolation of anything else. The teamPosition is the best guess for which position the player actually played if we add the constraint that each team must have one top player, one jungle, one middle, etc. Generally the recommendation is to use the teamPosition field over the individualPosition field. */
        teamPosition: string;
        timeCCingOthers: int;
        timePlayed: int;
        totalDamageDealt: int;
        totalDamageDealtToChampions: int;
        totalDamageShieldedOnTeammates: int;
        totalDamageTaken: int;
        totalHeal: int;
        totalHealsOnTeammates: int;
        totalMinionsKilled: int;
        totalTimeCCDealt: int;
        totalTimeSpentDead: int;
        totalUnitsHealed: int;
        tripleKills: int;
        trueDamageDealt: int;
        trueDamageDealtToChampions: int;
        trueDamageTaken: int;
        turretKills: int;
        turretTakedowns?: int | null;
        turretsLost: int;
        unrealKills: int;
        visionScore: int;
        visionWardsBoughtInGame: int;
        wardsKilled: int;
        wardsPlaced: int;
        win: boolean;
    }
}
export declare namespace matchV5 {
    /**
     * PerksDto data object, automatically generated.
     */
    interface PerksDto {
        statPerks: matchV5.PerkStatsDto;
        styles: matchV5.PerkStyleDto[];
    }
}
export declare namespace matchV5 {
    /**
     * PerkStatsDto data object, automatically generated.
     */
    interface PerkStatsDto {
        defense: int;
        flex: int;
        offense: int;
    }
}
export declare namespace matchV5 {
    /**
     * PerkStyleDto data object, automatically generated.
     */
    interface PerkStyleDto {
        description: string;
        selections: matchV5.PerkStyleSelectionDto[];
        style: int;
    }
}
export declare namespace matchV5 {
    /**
     * PerkStyleSelectionDto data object, automatically generated.
     */
    interface PerkStyleSelectionDto {
        perk: int;
        var1: int;
        var2: int;
        var3: int;
    }
}
export declare namespace matchV5 {
    /**
     * TeamDto data object, automatically generated.
     */
    interface TeamDto {
        bans: matchV5.BanDto[];
        objectives: matchV5.ObjectivesDto;
        teamId: int;
        win: boolean;
    }
}
export declare namespace matchV5 {
    /**
     * BanDto data object, automatically generated.
     */
    interface BanDto {
        championId: int;
        pickTurn: int;
    }
}
export declare namespace matchV5 {
    /**
     * ObjectivesDto data object, automatically generated.
     */
    interface ObjectivesDto {
        baron: matchV5.ObjectiveDto;
        champion: matchV5.ObjectiveDto;
        dragon: matchV5.ObjectiveDto;
        inhibitor: matchV5.ObjectiveDto;
        riftHerald: matchV5.ObjectiveDto;
        tower: matchV5.ObjectiveDto;
    }
}
export declare namespace matchV5 {
    /**
     * ObjectiveDto data object, automatically generated.
     */
    interface ObjectiveDto {
        first: boolean;
        kills: int;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineDto data object, automatically generated.
     */
    interface MatchTimelineDto {
        metadata: matchV5.MetadataDto;
        info: matchV5.MatchTimelineInfo;
    }
}
export declare namespace spectatorV4 {
    /**
     * CurrentGameInfo data object, automatically generated.
     */
    interface CurrentGameInfo {
        /** The ID of the game */
        gameId: long;
        /** The game type */
        gameType: string;
        /** The game start time represented in epoch milliseconds */
        gameStartTime: long;
        /** The ID of the map */
        mapId: long;
        /** The amount of time in seconds that has passed since the game started */
        gameLength: long;
        /** The ID of the platform on which the game is being played */
        platformId: string;
        /** The game mode */
        gameMode: string;
        /** Banned champion information */
        bannedChampions: spectatorV4.BannedChampion[];
        /** The queue type (queue types are documented on the Game Constants page) */
        gameQueueConfigId?: long | null;
        /** The observer information */
        observers: spectatorV4.Observer;
        /** The participant information */
        participants: spectatorV4.CurrentGameParticipant[];
    }
}
export declare namespace spectatorV4 {
    /**
     * BannedChampion data object, automatically generated.
     */
    interface BannedChampion {
        /** The turn during which the champion was banned */
        pickTurn: int;
        /** The ID of the banned champion */
        championId: long;
        /** The ID of the team that banned the champion */
        teamId: long;
    }
}
export declare namespace spectatorV4 {
    /**
     * Observer data object, automatically generated.
     */
    interface Observer {
        /** Key used to decrypt the spectator grid game data for playback */
        encryptionKey: string;
    }
}
export declare namespace spectatorV4 {
    /**
     * CurrentGameParticipant data object, automatically generated.
     */
    interface CurrentGameParticipant {
        /** The ID of the champion played by this participant */
        championId: long;
        /** Perks/Runes Reforged Information */
        perks?: spectatorV4.Perks | null;
        /** The ID of the profile icon used by this participant */
        profileIconId: long;
        /** Flag indicating whether or not this participant is a bot */
        bot: boolean;
        /** The team ID of this participant, indicating the participant's team */
        teamId: long;
        /** The summoner name of this participant */
        summonerName: string;
        /** The encrypted summoner ID of this participant */
        summonerId: string;
        /** The ID of the first summoner spell used by this participant */
        spell1Id: long;
        /** The ID of the second summoner spell used by this participant */
        spell2Id: long;
        /** List of Game Customizations */
        gameCustomizationObjects: spectatorV4.GameCustomizationObject[];
    }
}
export declare namespace spectatorV4 {
    /**
     * Perks data object, automatically generated.
     */
    interface Perks {
        /** IDs of the perks/runes assigned. */
        perkIds: long[];
        /** Primary runes path */
        perkStyle: long;
        /** Secondary runes path */
        perkSubStyle: long;
    }
}
export declare namespace spectatorV4 {
    /**
     * GameCustomizationObject data object, automatically generated.
     */
    interface GameCustomizationObject {
        /** Category identifier for Game Customization */
        category: string;
        /** Game Customization content */
        content: string;
    }
}
export declare namespace spectatorV4 {
    /**
     * FeaturedGames data object, automatically generated.
     */
    interface FeaturedGames {
        /** The list of featured games */
        gameList: spectatorV4.FeaturedGameInfo[];
        /** The suggested interval to wait before requesting FeaturedGames again */
        clientRefreshInterval: long;
    }
}
export declare namespace spectatorV4 {
    /**
     * FeaturedGameInfo data object, automatically generated.
     */
    interface FeaturedGameInfo {
        /** The game mode
             (Legal values:  CLASSIC,  ODIN,  ARAM,  TUTORIAL,  ONEFORALL,  ASCENSION,  FIRSTBLOOD,  KINGPORO) */
        gameMode: "CLASSIC" | "ODIN" | "ARAM" | "TUTORIAL" | "ONEFORALL" | "ASCENSION" | "FIRSTBLOOD" | "KINGPORO";
        /** The amount of time in seconds that has passed since the game started */
        gameLength: long;
        /** The ID of the map */
        mapId: long;
        /** The game type
             (Legal values:  CUSTOM_GAME,  MATCHED_GAME,  TUTORIAL_GAME) */
        gameType: "CUSTOM_GAME" | "MATCHED_GAME" | "TUTORIAL_GAME";
        /** Banned champion information */
        bannedChampions: spectatorV4.BannedChampion[];
        /** The ID of the game */
        gameId: long;
        /** The observer information */
        observers: spectatorV4.Observer;
        /** The queue type (queue types are documented on the Game Constants page) */
        gameQueueConfigId: long;
        /** The game start time represented in epoch milliseconds */
        gameStartTime: long;
        /** The participant information */
        participants: spectatorV4.Participant[];
        /** The ID of the platform on which the game is being played */
        platformId: string;
    }
}
export declare namespace spectatorV4 {
    /**
     * Participant data object, automatically generated.
     */
    interface Participant {
        /** Flag indicating whether or not this participant is a bot */
        bot: boolean;
        /** The ID of the second summoner spell used by this participant */
        spell2Id: long;
        /** The ID of the profile icon used by this participant */
        profileIconId: long;
        /** The summoner name of this participant */
        summonerName: string;
        /** The ID of the champion played by this participant */
        championId: long;
        /** The team ID of this participant, indicating the participant's team */
        teamId: long;
        /** The ID of the first summoner spell used by this participant */
        spell1Id: long;
    }
}
export declare namespace summonerV4 {
    /**
     * SummonerDTO data object, automatically generated.
     * # Description
     * represents a summoner
     */
    interface SummonerDTO {
        /** Encrypted account ID. Max length 56 characters. */
        accountId: string;
        /** ID of the summoner icon associated with the summoner. */
        profileIconId: int;
        /** Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: profile icon change, playing the tutorial or advanced tutorial, finishing a game, summoner name change */
        revisionDate: long;
        /** Summoner name. */
        name: string;
        /** Encrypted summoner ID. Max length 63 characters. */
        id: string;
        /** Encrypted PUUID. Exact length of 78 characters. */
        puuid: string;
        /** Summoner level associated with the summoner. */
        summonerLevel: long;
    }
}
export declare namespace tftLeagueV1 {
    /**
     * LeagueListDTO data object, automatically generated.
     */
    interface LeagueListDTO {
        leagueId: string;
        entries: tftLeagueV1.LeagueItemDTO[];
        tier: string;
        name: string;
        queue: string;
    }
}
export declare namespace tftLeagueV1 {
    /**
     * LeagueItemDTO data object, automatically generated.
     */
    interface LeagueItemDTO {
        freshBlood: boolean;
        /** First placement. */
        wins: int;
        summonerName: string;
        miniSeries?: tftLeagueV1.MiniSeriesDTO | null;
        inactive: boolean;
        veteran: boolean;
        hotStreak: boolean;
        rank: string;
        leaguePoints: int;
        /** Second through eighth placement. */
        losses: int;
        /** Player's encrypted summonerId. */
        summonerId: string;
    }
}
export declare namespace tftLeagueV1 {
    /**
     * MiniSeriesDTO data object, automatically generated.
     */
    interface MiniSeriesDTO {
        losses: int;
        progress: string;
        target: int;
        wins: int;
    }
}
export declare namespace tftLeagueV1 {
    /**
     * LeagueEntryDTO data object, automatically generated.
     */
    interface LeagueEntryDTO {
        /** Not included for the RANKED_TFT_TURBO queueType. */
        leagueId?: string | null;
        /** Player's encrypted summonerId. */
        summonerId: string;
        summonerName: string;
        queueType: string;
        /** Only included for the RANKED_TFT_TURBO queueType.
             (Legal values:  ORANGE,  PURPLE,  BLUE,  GREEN,  GRAY) */
        ratedTier?: "ORANGE" | "PURPLE" | "BLUE" | "GREEN" | "GRAY" | null;
        /** Only included for the RANKED_TFT_TURBO queueType. */
        ratedRating?: int | null;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        tier?: string | null;
        /** A player's division within a tier. Not included for the RANKED_TFT_TURBO queueType. */
        rank?: string | null;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        leaguePoints?: int | null;
        /** First placement. */
        wins: int;
        /** Second through eighth placement. */
        losses: int;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        hotStreak?: boolean | null;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        veteran?: boolean | null;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        freshBlood?: boolean | null;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        inactive?: boolean | null;
        /** Not included for the RANKED_TFT_TURBO queueType. */
        miniSeries?: tftLeagueV1.MiniSeriesDTO | null;
    }
}
export declare namespace tftLeagueV1 {
    /**
     * TopRatedLadderEntryDto data object, automatically generated.
     */
    interface TopRatedLadderEntryDto {
        summonerId: string;
        summonerName: string;
        /** (Legal values:  ORANGE,  PURPLE,  BLUE,  GREEN,  GRAY) */
        ratedTier: "ORANGE" | "PURPLE" | "BLUE" | "GREEN" | "GRAY";
        ratedRating: int;
        /** First placement. */
        wins: int;
        previousUpdateLadderPosition: int;
    }
}
export declare namespace tftMatchV1 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        /** Match metadata. */
        metadata: tftMatchV1.MetadataDto;
        /** Match info. */
        info: tftMatchV1.InfoDto;
    }
}
export declare namespace tftMatchV1 {
    /**
     * MetadataDto data object, automatically generated.
     */
    interface MetadataDto {
        /** Match data version. */
        data_version: string;
        /** Match id. */
        match_id: string;
        /** A list of participant PUUIDs. */
        participants: string[];
    }
}
export declare namespace tftMatchV1 {
    /**
     * InfoDto data object, automatically generated.
     */
    interface InfoDto {
        /** Unix timestamp. */
        game_datetime: long;
        /** Game length in seconds. */
        game_length: float;
        /** Game variation key. Game variations documented in TFT static data. */
        game_variation?: string | null;
        /** Game client version. */
        game_version: string;
        participants: tftMatchV1.ParticipantDto[];
        /** Please refer to the League of Legends documentation. */
        queue_id: int;
        /** Teamfight Tactics set number. */
        tft_set_number: int;
    }
}
export declare namespace tftMatchV1 {
    /**
     * ParticipantDto data object, automatically generated.
     */
    interface ParticipantDto {
        /** Participant's companion. */
        companion: tftMatchV1.CompanionDto;
        /** Gold left after participant was eliminated. */
        gold_left: int;
        /** The round the participant was eliminated in. Note: If the player was eliminated in stage 2-1 their last_round would be 5. */
        last_round: int;
        /** Participant Little Legend level. Note: This is not the number of active units. */
        level: int;
        /** Participant placement upon elimination. */
        placement: int;
        /** Number of players the participant eliminated. */
        players_eliminated: int;
        puuid: string;
        /** The number of seconds before the participant was eliminated. */
        time_eliminated: float;
        /** Damage the participant dealt to other players. */
        total_damage_to_players: int;
        /** A complete list of traits for the participant's active units. */
        traits: tftMatchV1.TraitDto[];
        /** A list of active units for the participant. */
        units: tftMatchV1.UnitDto[];
    }
}
export declare namespace tftMatchV1 {
    /**
     * TraitDto data object, automatically generated.
     */
    interface TraitDto {
        /** Trait name. */
        name: string;
        /** Number of units with this trait. */
        num_units: int;
        /** Current style for this trait. (0 = No style, 1 = Bronze, 2 = Silver, 3 = Gold, 4 = Chromatic) */
        style?: int | null;
        /** Current active tier for the trait. */
        tier_current: int;
        /** Total tiers for the trait. */
        tier_total?: int | null;
    }
}
export declare namespace tftMatchV1 {
    /**
     * UnitDto data object, automatically generated.
     */
    interface UnitDto {
        /** A list of the unit's items. Please refer to the Teamfight Tactics documentation for item ids. */
        items: int[];
        /** This field was introduced in patch 9.22 with data_version 2. */
        character_id: string;
        /** If a unit is chosen as part of the Fates set mechanic, the chosen trait will be indicated by this field. Otherwise this field is excluded from the response. */
        chosen?: string | null;
        /** Unit name. This field is often left blank. */
        name: string;
        /** Unit rarity. This doesn't equate to the unit cost. */
        rarity: int;
        /** Unit tier. */
        tier: int;
    }
}
export declare namespace tftMatchV1 {
    /**
     * CompanionDto data object, automatically generated.
     */
    interface CompanionDto {
        skin_ID: int;
        content_ID: string;
        species: string;
    }
}
export declare namespace tftSummonerV1 {
    /**
     * SummonerDTO data object, automatically generated.
     * # Description
     * represents a summoner
     */
    interface SummonerDTO {
        /** Encrypted account ID. Max length 56 characters. */
        accountId: string;
        /** ID of the summoner icon associated with the summoner. */
        profileIconId: int;
        /** Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: summoner name change, summoner level change, or profile icon change. */
        revisionDate: long;
        /** Summoner name. */
        name: string;
        /** Encrypted summoner ID. Max length 63 characters. */
        id: string;
        /** Encrypted PUUID. Exact length of 78 characters. */
        puuid: string;
        /** Summoner level associated with the summoner. */
        summonerLevel: long;
    }
}
export declare namespace tournamentStubV4 {
    /**
     * TournamentCodeParameters data object, automatically generated.
     */
    interface TournamentCodeParameters {
        /** Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future. */
        allowedSummonerIds?: string[] | null;
        /** Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game. */
        metadata?: string | null;
        /** The team size of the game. Valid values are 1-5. */
        teamSize: int;
        /** The pick type of the game.
             (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT) */
        pickType: "BLIND_PICK" | "DRAFT_MODE" | "ALL_RANDOM" | "TOURNAMENT_DRAFT";
        /** The map type of the game.
             (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS) */
        mapType: "SUMMONERS_RIFT" | "TWISTED_TREELINE" | "HOWLING_ABYSS";
        /** The spectator type of the game.
             (Legal values:  NONE,  LOBBYONLY,  ALL) */
        spectatorType: "NONE" | "LOBBYONLY" | "ALL";
    }
}
export declare namespace tournamentStubV4 {
    /**
     * LobbyEventDTOWrapper data object, automatically generated.
     */
    interface LobbyEventDTOWrapper {
        eventList: tournamentStubV4.LobbyEventDTO[];
    }
}
export declare namespace tournamentStubV4 {
    /**
     * LobbyEventDTO data object, automatically generated.
     */
    interface LobbyEventDTO {
        /** The summonerId that triggered the event (Encrypted) */
        summonerId: string;
        /** The type of event that was triggered */
        eventType: string;
        /** Timestamp from the event */
        timestamp: string;
    }
}
export declare namespace tournamentStubV4 {
    /**
     * ProviderRegistrationParameters data object, automatically generated.
     */
    interface ProviderRegistrationParameters {
        /** The region in which the provider will be running tournaments.
             (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR) */
        region: "BR" | "EUNE" | "EUW" | "JP" | "LAN" | "LAS" | "NA" | "OCE" | "PBE" | "RU" | "TR";
        /** The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443). */
        url: string;
    }
}
export declare namespace tournamentStubV4 {
    /**
     * TournamentRegistrationParameters data object, automatically generated.
     */
    interface TournamentRegistrationParameters {
        /** The provider ID to specify the regional registered provider data to associate this tournament. */
        providerId: int;
        /** The optional name of the tournament. */
        name?: string | null;
    }
}
export declare namespace tournamentV4 {
    /**
     * TournamentCodeParameters data object, automatically generated.
     */
    interface TournamentCodeParameters {
        /** Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future. */
        allowedSummonerIds?: string[] | null;
        /** Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game. */
        metadata?: string | null;
        /** The team size of the game. Valid values are 1-5. */
        teamSize: int;
        /** The pick type of the game.
             (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT) */
        pickType: "BLIND_PICK" | "DRAFT_MODE" | "ALL_RANDOM" | "TOURNAMENT_DRAFT";
        /** The map type of the game.
             (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS) */
        mapType: "SUMMONERS_RIFT" | "TWISTED_TREELINE" | "HOWLING_ABYSS";
        /** The spectator type of the game.
             (Legal values:  NONE,  LOBBYONLY,  ALL) */
        spectatorType: "NONE" | "LOBBYONLY" | "ALL";
    }
}
export declare namespace tournamentV4 {
    /**
     * TournamentCodeDTO data object, automatically generated.
     */
    interface TournamentCodeDTO {
        /** The tournament code. */
        code: string;
        /** The spectator mode for the tournament code game. */
        spectators: string;
        /** The lobby name for the tournament code game. */
        lobbyName: string;
        /** The metadata for tournament code. */
        metaData: string;
        /** The password for the tournament code game. */
        password: string;
        /** The team size for the tournament code game. */
        teamSize: int;
        /** The provider's ID. */
        providerId: int;
        /** The pick mode for tournament code game. */
        pickType: string;
        /** The tournament's ID. */
        tournamentId: int;
        /** The tournament code's ID. */
        id: int;
        /** The tournament code's region.
             (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR) */
        region: "BR" | "EUNE" | "EUW" | "JP" | "LAN" | "LAS" | "NA" | "OCE" | "PBE" | "RU" | "TR";
        /** The game map for the tournament code game */
        map: string;
        /** The summonerIds of the participants (Encrypted) */
        participants: string[];
    }
}
export declare namespace tournamentV4 {
    /**
     * TournamentCodeUpdateParameters data object, automatically generated.
     */
    interface TournamentCodeUpdateParameters {
        /** Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future. */
        allowedSummonerIds?: string[] | null;
        /** The pick type
             (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT) */
        pickType: "BLIND_PICK" | "DRAFT_MODE" | "ALL_RANDOM" | "TOURNAMENT_DRAFT";
        /** The map type
             (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS) */
        mapType: "SUMMONERS_RIFT" | "TWISTED_TREELINE" | "HOWLING_ABYSS";
        /** The spectator type
             (Legal values:  NONE,  LOBBYONLY,  ALL) */
        spectatorType: "NONE" | "LOBBYONLY" | "ALL";
    }
}
export declare namespace tournamentV4 {
    /**
     * LobbyEventDTOWrapper data object, automatically generated.
     */
    interface LobbyEventDTOWrapper {
        eventList: tournamentV4.LobbyEventDTO[];
    }
}
export declare namespace tournamentV4 {
    /**
     * LobbyEventDTO data object, automatically generated.
     */
    interface LobbyEventDTO {
        /** Timestamp from the event */
        timestamp: string;
        /** The type of event that was triggered */
        eventType: string;
        /** The summonerId that triggered the event (Encrypted) */
        summonerId: string;
    }
}
export declare namespace tournamentV4 {
    /**
     * ProviderRegistrationParameters data object, automatically generated.
     */
    interface ProviderRegistrationParameters {
        /** The region in which the provider will be running tournaments.
             (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR) */
        region: "BR" | "EUNE" | "EUW" | "JP" | "LAN" | "LAS" | "NA" | "OCE" | "PBE" | "RU" | "TR";
        /** The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443). */
        url: string;
    }
}
export declare namespace tournamentV4 {
    /**
     * TournamentRegistrationParameters data object, automatically generated.
     */
    interface TournamentRegistrationParameters {
        /** The provider ID to specify the regional registered provider data to associate this tournament. */
        providerId: int;
        /** The optional name of the tournament. */
        name?: string | null;
    }
}
export declare namespace valContentV1 {
    /**
     * ContentDto data object, automatically generated.
     */
    interface ContentDto {
        version: string;
        characters: valContentV1.ContentItemDto[];
        maps: valContentV1.ContentItemDto[];
        chromas: valContentV1.ContentItemDto[];
        skins: valContentV1.ContentItemDto[];
        skinLevels: valContentV1.ContentItemDto[];
        equips: valContentV1.ContentItemDto[];
        gameModes: valContentV1.ContentItemDto[];
        sprays: valContentV1.ContentItemDto[];
        sprayLevels: valContentV1.ContentItemDto[];
        charms: valContentV1.ContentItemDto[];
        charmLevels: valContentV1.ContentItemDto[];
        playerCards: valContentV1.ContentItemDto[];
        playerTitles: valContentV1.ContentItemDto[];
        acts: valContentV1.ActDto[];
    }
}
export declare namespace valContentV1 {
    /**
     * ContentItemDto data object, automatically generated.
     */
    interface ContentItemDto {
        name: string;
        /** This field is excluded from the response when a locale is set */
        localizedNames?: valContentV1.LocalizedNamesDto | null;
        id: string;
        assetName: string;
        /** This field is only included for maps and game modes. These values are used in the match response. */
        assetPath?: string | null;
    }
}
export declare namespace valContentV1 {
    /**
     * LocalizedNamesDto data object, automatically generated.
     */
    interface LocalizedNamesDto {
        "ar-AE": string;
        "de-DE": string;
        "en-GB": string;
        "en-US": string;
        "es-ES": string;
        "es-MX": string;
        "fr-FR": string;
        "id-ID": string;
        "it-IT": string;
        "ja-JP": string;
        "ko-KR": string;
        "pl-PL": string;
        "pt-BR": string;
        "ru-RU": string;
        "th-TH": string;
        "tr-TR": string;
        "vi-VN": string;
        "zh-CN": string;
        "zh-TW": string;
    }
}
export declare namespace valContentV1 {
    /**
     * ActDto data object, automatically generated.
     */
    interface ActDto {
        name: string;
        /** This field is excluded from the response when a locale is set */
        localizedNames?: valContentV1.LocalizedNamesDto | null;
        id: string;
        isActive: boolean;
    }
}
export declare namespace valMatchV1 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        matchInfo: valMatchV1.MatchInfoDto;
        players: valMatchV1.PlayerDto[];
        coaches: valMatchV1.CoachDto[];
        teams: valMatchV1.TeamDto[];
        roundResults: valMatchV1.RoundResultDto[];
    }
}
export declare namespace valMatchV1 {
    /**
     * MatchInfoDto data object, automatically generated.
     */
    interface MatchInfoDto {
        matchId: string;
        mapId: string;
        gameLengthMillis: int;
        gameStartMillis: long;
        provisioningFlowId: string;
        isCompleted: boolean;
        customGameName: string;
        queueId: string;
        gameMode: string;
        isRanked: boolean;
        seasonId: string;
    }
}
export declare namespace valMatchV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        puuid: string;
        gameName: string;
        tagLine: string;
        teamId: string;
        partyId: string;
        characterId: string;
        stats: valMatchV1.PlayerStatsDto;
        competitiveTier: int;
        playerCard: string;
        playerTitle: string;
    }
}
export declare namespace valMatchV1 {
    /**
     * PlayerStatsDto data object, automatically generated.
     */
    interface PlayerStatsDto {
        score: int;
        roundsPlayed: int;
        kills: int;
        deaths: int;
        assists: int;
        playtimeMillis: int;
        abilityCasts: valMatchV1.AbilityCastsDto;
    }
}
export declare namespace valMatchV1 {
    /**
     * AbilityCastsDto data object, automatically generated.
     */
    interface AbilityCastsDto {
        grenadeCasts: int;
        ability1Casts: int;
        ability2Casts: int;
        ultimateCasts: int;
    }
}
export declare namespace valMatchV1 {
    /**
     * CoachDto data object, automatically generated.
     */
    interface CoachDto {
        puuid: string;
        teamId: string;
    }
}
export declare namespace valMatchV1 {
    /**
     * TeamDto data object, automatically generated.
     */
    interface TeamDto {
        /** This is an arbitrary string. Red and Blue in bomb modes. The puuid of the player in deathmatch. */
        teamId: string;
        won: boolean;
        roundsPlayed: int;
        roundsWon: int;
        /** Team points scored. Number of kills in deathmatch. */
        numPoints: int;
    }
}
export declare namespace valMatchV1 {
    /**
     * RoundResultDto data object, automatically generated.
     */
    interface RoundResultDto {
        roundNum: int;
        roundResult: string;
        roundCeremony: string;
        winningTeam: string;
        /** PUUID of player */
        bombPlanter: string;
        /** PUUID of player */
        bombDefuser: string;
        plantRoundTime: int;
        plantPlayerLocations: valMatchV1.PlayerLocationsDto[];
        plantLocation: valMatchV1.LocationDto;
        plantSite: string;
        defuseRoundTime: int;
        defusePlayerLocations: valMatchV1.PlayerLocationsDto[];
        defuseLocation: valMatchV1.LocationDto;
        playerStats: valMatchV1.PlayerRoundStatsDto[];
        roundResultCode: string;
    }
}
export declare namespace valMatchV1 {
    /**
     * PlayerLocationsDto data object, automatically generated.
     */
    interface PlayerLocationsDto {
        puuid: string;
        viewRadians: float;
        location: valMatchV1.LocationDto;
    }
}
export declare namespace valMatchV1 {
    /**
     * LocationDto data object, automatically generated.
     */
    interface LocationDto {
        x: int;
        y: int;
    }
}
export declare namespace valMatchV1 {
    /**
     * PlayerRoundStatsDto data object, automatically generated.
     */
    interface PlayerRoundStatsDto {
        puuid: string;
        kills: valMatchV1.KillDto[];
        damage: valMatchV1.DamageDto[];
        score: int;
        economy: valMatchV1.EconomyDto;
        ability: valMatchV1.AbilityDto;
    }
}
export declare namespace valMatchV1 {
    /**
     * KillDto data object, automatically generated.
     */
    interface KillDto {
        timeSinceGameStartMillis: int;
        timeSinceRoundStartMillis: int;
        /** PUUID */
        killer: string;
        /** PUUID */
        victim: string;
        victimLocation: valMatchV1.LocationDto;
        /** List of PUUIDs */
        assistants: string[];
        playerLocations: valMatchV1.PlayerLocationsDto[];
        finishingDamage: valMatchV1.FinishingDamageDto;
    }
}
export declare namespace valMatchV1 {
    /**
     * FinishingDamageDto data object, automatically generated.
     */
    interface FinishingDamageDto {
        damageType: string;
        damageItem: string;
        isSecondaryFireMode: boolean;
    }
}
export declare namespace valMatchV1 {
    /**
     * DamageDto data object, automatically generated.
     */
    interface DamageDto {
        /** PUUID */
        receiver: string;
        damage: int;
        legshots: int;
        bodyshots: int;
        headshots: int;
    }
}
export declare namespace valMatchV1 {
    /**
     * EconomyDto data object, automatically generated.
     */
    interface EconomyDto {
        loadoutValue: int;
        weapon: string;
        armor: string;
        remaining: int;
        spent: int;
    }
}
export declare namespace valMatchV1 {
    /**
     * AbilityDto data object, automatically generated.
     */
    interface AbilityDto {
        grenadeEffects: string;
        ability1Effects: string;
        ability2Effects: string;
        ultimateEffects: string;
    }
}
export declare namespace valMatchV1 {
    /**
     * MatchlistDto data object, automatically generated.
     */
    interface MatchlistDto {
        puuid: string;
        history: valMatchV1.MatchlistEntryDto[];
    }
}
export declare namespace valMatchV1 {
    /**
     * MatchlistEntryDto data object, automatically generated.
     */
    interface MatchlistEntryDto {
        matchId: string;
        gameStartTimeMillis: long;
        teamId: string;
    }
}
export declare namespace valMatchV1 {
    /**
     * RecentMatchesDto data object, automatically generated.
     */
    interface RecentMatchesDto {
        currentTime: long;
        /** A list of recent match ids. */
        matchIds: string[];
    }
}
export declare namespace valRankedV1 {
    /**
     * LeaderboardDto data object, automatically generated.
     */
    interface LeaderboardDto {
        /** The shard for the given leaderboard. */
        shard: string;
        /** The act id for the given leaderboard. Act ids can be found using the val-content API. */
        actId: string;
        /** The total number of players in the leaderboard. */
        totalPlayers: long;
        players: valRankedV1.PlayerDto[];
    }
}
export declare namespace valRankedV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        /** This field may be omitted if the player has been anonymized. */
        puuid?: string | null;
        /** This field may be omitted if the player has been anonymized. */
        gameName?: string | null;
        /** This field may be omitted if the player has been anonymized. */
        tagLine?: string | null;
        leaderboardRank: long;
        rankedRating: long;
        numberOfWins: long;
    }
}
export declare namespace valStatusV1 {
    /**
     * PlatformDataDto data object, automatically generated.
     */
    interface PlatformDataDto {
        id: string;
        name: string;
        locales: string[];
        maintenances: valStatusV1.StatusDto[];
        incidents: valStatusV1.StatusDto[];
    }
}
export declare namespace valStatusV1 {
    /**
     * StatusDto data object, automatically generated.
     */
    interface StatusDto {
        id: int;
        /** (Legal values:  scheduled,  in_progress,  complete) */
        maintenance_status: "scheduled" | "in_progress" | "complete";
        /** (Legal values:  info,  warning,  critical) */
        incident_severity: "info" | "warning" | "critical";
        titles: valStatusV1.ContentDto[];
        updates: valStatusV1.UpdateDto[];
        created_at: string;
        archive_at: string;
        updated_at: string;
        /** (Legal values: windows, macos, android, ios, ps4, xbone, switch) */
        platforms: string[];
    }
}
export declare namespace valStatusV1 {
    /**
     * ContentDto data object, automatically generated.
     */
    interface ContentDto {
        locale: string;
        content: string;
    }
}
export declare namespace valStatusV1 {
    /**
     * UpdateDto data object, automatically generated.
     */
    interface UpdateDto {
        id: int;
        author: string;
        publish: boolean;
        /** (Legal values: riotclient, riotstatus, game) */
        publish_locations: string[];
        translations: valStatusV1.ContentDto[];
        created_at: string;
        updated_at: string;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrameEvent data object, automatically generated.
     */
    interface MatchTimelineInfoFrameEvent {
        realTimestamp?: int | null;
        timestamp: int;
        /** Timeline event type.
(Known legal values: ASCENDED_EVENT, BUILDING_KILL, CAPTURE_POINT, CHAMPION_KILL, CHAMPION_SPECIAL_KILL, CHAMPION_TRANSFORM, DRAGON_SOUL_GIVEN, ELITE_MONSTER_KILL, GAME_END, ITEM_DESTROYED, ITEM_PURCHASED, ITEM_SOLD, ITEM_UNDO, LEVEL_UP, PAUSE_END, PAUSE_START, SKILL_LEVEL_UP, TURRET_PLATE_DESTROYED, WARD_KILL, WARD_PLACED) */
        type: "ASCENDED_EVENT" | "BUILDING_KILL" | "CAPTURE_POINT" | "CHAMPION_KILL" | "CHAMPION_SPECIAL_KILL" | "CHAMPION_TRANSFORM" | "DRAGON_SOUL_GIVEN" | "ELITE_MONSTER_KILL" | "GAME_END" | "ITEM_DESTROYED" | "ITEM_PURCHASED" | "ITEM_SOLD" | "ITEM_UNDO" | "LEVEL_UP" | "PAUSE_END" | "PAUSE_START" | "SKILL_LEVEL_UP" | "TURRET_PLATE_DESTROYED" | "WARD_KILL" | "WARD_PLACED";
        itemId?: int | null;
        participantId?: int | null;
        levelUpType?: string | null;
        skillSlot?: int | null;
        creatorId?: int | null;
        wardType?: string | null;
        level?: int | null;
        assistingParticipantIds?: int[] | null;
        bounty?: int | null;
        killStreakLength?: int | null;
        killerId?: int | null;
        position?: matchV5.MatchTimelinePosition | null;
        victimDamageDealt?: matchV5.MatchTimelineInfoFrameEventVictimDamageDealt[] | null;
        victimDamageReceived?: matchV5.MatchTimelineInfoFrameEventVictimDamageDealt[] | null;
        victimId?: int | null;
        killType?: string | null;
        laneType?: string | null;
        teamId?: int | null;
        multiKillLength?: int | null;
        killerTeamId?: int | null;
        monsterType?: string | null;
        monsterSubType?: string | null;
        buildingType?: string | null;
        towerType?: string | null;
        afterId?: int | null;
        beforeId?: int | null;
        goldGain?: int | null;
        gameId?: int | null;
        winningTeam?: int | null;
        transformType?: string | null;
        name?: string | null;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrameParticipantFrameChampionStats data object, automatically generated.
     */
    interface MatchTimelineInfoFrameParticipantFrameChampionStats {
        abilityHaste?: int | null;
        abilityPower: int;
        armor: int;
        armorPen: int;
        armorPenPercent: int;
        attackDamage: int;
        attackSpeed: int;
        bonusArmorPenPercent: int;
        bonusMagicPenPercent: int;
        ccReduction: int;
        cooldownReduction: int;
        health: int;
        healthMax: int;
        healthRegen: int;
        lifesteal: int;
        magicPen: int;
        magicPenPercent: int;
        magicResist: int;
        movementSpeed: int;
        omnivamp?: int | null;
        physicalVamp?: int | null;
        power: int;
        powerMax: int;
        powerRegen: int;
        spellVamp: int;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrameParticipantFrameDamageStats data object, automatically generated.
     */
    interface MatchTimelineInfoFrameParticipantFrameDamageStats {
        magicDamageDone: int;
        magicDamageDoneToChampions: int;
        magicDamageTaken: int;
        physicalDamageDone: int;
        physicalDamageDoneToChampions: int;
        physicalDamageTaken: int;
        totalDamageDone: int;
        totalDamageDoneToChampions: int;
        totalDamageTaken: int;
        trueDamageDone: int;
        trueDamageDoneToChampions: int;
        trueDamageTaken: int;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelinePosition data object, automatically generated.
     */
    interface MatchTimelinePosition {
        x: int;
        y: int;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrameParticipantFrame data object, automatically generated.
     */
    interface MatchTimelineInfoFrameParticipantFrame {
        championStats: matchV5.MatchTimelineInfoFrameParticipantFrameChampionStats;
        currentGold: int;
        damageStats: matchV5.MatchTimelineInfoFrameParticipantFrameDamageStats;
        goldPerSecond: int;
        jungleMinionsKilled: int;
        level: int;
        minionsKilled: int;
        participantId: int;
        position: matchV5.MatchTimelinePosition;
        timeEnemySpentControlled: int;
        totalGold: int;
        xp: int;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrameParticipantFrames data object, automatically generated.
     */
    interface MatchTimelineInfoFrameParticipantFrames {
        1: matchV5.MatchTimelineInfoFrameParticipantFrame;
        2: matchV5.MatchTimelineInfoFrameParticipantFrame;
        3: matchV5.MatchTimelineInfoFrameParticipantFrame;
        4: matchV5.MatchTimelineInfoFrameParticipantFrame;
        5: matchV5.MatchTimelineInfoFrameParticipantFrame;
        6: matchV5.MatchTimelineInfoFrameParticipantFrame;
        7: matchV5.MatchTimelineInfoFrameParticipantFrame;
        8: matchV5.MatchTimelineInfoFrameParticipantFrame;
        9: matchV5.MatchTimelineInfoFrameParticipantFrame;
        10: matchV5.MatchTimelineInfoFrameParticipantFrame;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrame data object, automatically generated.
     */
    interface MatchTimelineInfoFrame {
        events: matchV5.MatchTimelineInfoFrameEvent[];
        participantFrames: matchV5.MatchTimelineInfoFrameParticipantFrames;
        timestamp: int;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoFrameEventVictimDamageDealt data object, automatically generated.
     */
    interface MatchTimelineInfoFrameEventVictimDamageDealt {
        basic: boolean;
        magicDamage: int;
        name: string;
        participantId: int;
        physicalDamage: int;
        spellName: string;
        spellSlot: int;
        trueDamage: int;
        type: string;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfoParticipant data object, automatically generated.
     */
    interface MatchTimelineInfoParticipant {
        participantId: int;
        puuid: string;
    }
}
export declare namespace matchV5 {
    /**
     * MatchTimelineInfo data object, automatically generated.
     */
    interface MatchTimelineInfo {
        frameInterval: int;
        frames: matchV5.MatchTimelineInfoFrame[];
        gameId?: int | null;
        participants?: matchV5.MatchTimelineInfoParticipant[] | null;
    }
}
